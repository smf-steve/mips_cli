#! /bin/bash

for f in libexec/*.bash ; do
   source $f
done

PS1="(mips) "
segment=".text"

function mips_cli () {
  (
	PS1="(mips) "
	reset_registers
	bash --init-file mips_cli -i
  )
}

function .data () {
  segment=".data"
  PS1="(mips.data) "
}

function .text () {
  segment=".text"
  PS1="(mips) "
}

function execute () {
  _filename="$1"

  [[ -f $_filename ]] ||  { echo "$_filename not found" ; return 1; }
  while read _line; do
  	eval $_line
    sleep 2
  done < $_filename
}


max_immediate=$(( 2 ** 16 - 1 ))
max_pos_immediate=$(( 2 ** 15 - 1 ))
max_word=$(( 2 ** 32 - 1 ))
max_dword=$(( 2 ** 63 ))


##########################################################################
## Following are functions to convert output to more readable formats

## Convert a decimal number to hex with bytes separated
#    - format "0x XX XX XX XX XX"
function to_hex () {
  _size=${1}
  _decimal=${2}
  _hex=$(printf "%0${_size}X" ${_decimal} )

  # Make it a byte at a time:
  sed -e 's/\(..\)/ \1/g' -e 's/^ //' <<< $_hex
}

## Convert a hexadecimal number to binary with nibbles separated
#    - format "bbbb bbbb bbbb bbbb"
function to_binary () {
  _hex=${1}
  # Make it a nibble at a time
  _exploded=$(sed -e 's/ //g' -e 's/\(.\)/ \1/g' <<< $_hex)
  _value=""
  for i in $_exploded ; do
    case $i in 
       0   ) _value="${_value} 0000" ;;
       1   ) _value="${_value} 0001" ;;
       2   ) _value="${_value} 0010" ;;
       3   ) _value="${_value} 0011" ;;
       4   ) _value="${_value} 0100" ;;
       5   ) _value="${_value} 0101" ;;
       6   ) _value="${_value} 0110" ;;
       7   ) _value="${_value} 0111" ;;
       8   ) _value="${_value} 1000" ;;
       9   ) _value="${_value} 1001" ;;
       a|A ) _value="${_value} 1010" ;;
       b|B ) _value="${_value} 1011" ;;
       c|C ) _value="${_value} 1100" ;;
       d|D ) _value="${_value} 1101" ;;
       e|E ) _value="${_value} 1110" ;;
       f|F ) _value="${_value} 1111" ;;
    esac
  done
  echo $_value
}

function sign_contraction () {
    # technially, we should do this only if 
    #   all the bits above 32 bits are all ones ore all zeros

    _upper_word=$(( $1 >> 32 ))
    if (( _upper_word != 0x00000000 || _upper_word != 0xFFFFFFFF )) ; then
      echo "Error number out of range"
      return 1
    fi
    echo $(( $1 & 0xFFFFFFFF ))
}

function sign_extension() {
  # first convet to an int: see mips_subroutine to accept various inputs
  #   - e.g. 0x034, 045, 0bxxx, n# 101010 100101
  # second make sure it is only 16 bits
  # 
  _value="$1"

  _prefix=${_value:0:1}
  if [[ ${_prefix} == '~' || ${_prefix} == '-' ]] ; then 
  	_value="${_value:1}"
  else
  	_prefix=
  fi

  # 0x80000000 == 2 ** 15
  _sign_bit=$(( ${_value} & 0x80000000 ))
  if [[ ${sign_bit} == 1 ]] ; then 
   	# The sign bit is on... so extend it
    ((_value = - 0x80000000 | _value ))
  fi
  
  echo $(( ${_prefix}${_value} ))
}


################################################################################
# The argument list is as follows:
# execute_XXX   cmd op dst src1 src2
# execute_XXI   cmd op dst src1 imm
function execute_RRC() {
   # use the complemnt of the src2
  _cmd="$1"
  _op="$2"
  _dst="$(sed -e 's/,$//' <<< $3)"
  _src1="$(sed -e 's/,$//' <<< $4)"
  _src2="$5"

  echo ${_cmd} \$$(name $_dst), \$$(name $_src1), \$$(name $_src2)
  print_cin 1
  print_register $_src1
  print_register ~$_src2
  _value=$(( ($(rval $_src1) $_op ~ $(rval $_src2))  + 1 ))
  _value=$(sign_contraction $_value)
  assign $_dst $_value
  print_op $_op
  print_register $_dst

}

function execute_RRR() {
  
  _cmd="$1"
  _op="$2"
  _dst="$(sed -e 's/,$//' <<< $3)"
  _src1="$(sed -e 's/,$//' <<< $4)"
  _src2="$5"


  echo ${_cmd} \$$(name $_dst), \$$(name $_src1), \$$(name $_src2)
  print_register $_src1
  print_register $_src2
  _value=$(( $(rval $_src1) $_op $(rval $_src2)  ))
  _value=$(sign_contraction $_value)
  assign $_dst $_value
  print_op $_op
  print_register $_dst
}


function execute_RRI () {
  # It would be good if I could bring in the text string for the third arg
  _cmd="$1"
  _op="$2"
  _dst="$(sed -e 's/,$//' <<< $3)"
  _src1="$(sed -e 's/,$//' <<< $4)"
  _text="$5"
  _imm=$(read_immediate "$5")
  _value=$(sign_extension "$_imm")

  echo ${_cmd} \$$(name $_dst), \$$(name $_src1), $_imm  "    # \"$_text\""
  print_register $_src1
  print_immediate "$_imm" "$_text"

  _value=$(( $(rval $_src1) $_op ${_value} ))
  _value=$(sign_contraction  $_value)

  assign $_dst $_value    
  print_op $_op
  print_register $_dst
}

function execute_RR ()  {
	# For example:  move $t0, $t1
  _cmd="$1"
  _op="$2"
  _dst="$(sed -e 's/,$//' <<< $3)"
  _src1="$4"

  echo ${_cmd} \$$(name $_dst), \$$(name $_src1)
  print_register "$_src1"
  assign "$_dst" "$(rval $_src1)"
  print_op "$_op"
  print_register "$_dst"
}

function execute_RI ()  {
	# For example:  li $t0, imm
    # It would be good if I could bring in the text string for the third arg

  _op="$1"
  _dst="$(sed -e 's/,$//' <<< $2)"
  _imm="$3"

  print_register "$_src1"
  assign "$_dst" "$_src1"
  print_op "$_op"
  print_register "$_dst"
}


alias  add="execute_RRR add +"
alias  sub="execute_RRC sub +"
alias addi="execute_RRI addi +"
alias subi="invalid"
# addu

alias  sll="execute_RRI ssl '<<'"
alias  sra="execute_RRI sra '>>'"
alias sllv="execute_RRR sllv '<<'"
alias srav="execute_RRR srav '>>'"

alias  and="execute_RRR and \&"
alias   or="execute_RRR or \|"
alias  xor="execute_RRR xor ^"
#alias nor="execute_RRR "

alias andi="execute_RRI \&"
alias  ori="execute_RRI \|"
alias xori="execute_RRI ^"
alias nori="invalid"

alias mthi="execute_RR mthi move _hi"    # mfhi $t0
alias mtlo="execute_RR mtlo move _lo"    # mflo $t0

function reverse_op() {
  execute_RR $1, $2, $4, $3
}

alias mfhi="reverse_op mthi move _hi"       # mthi $t0
alias mflo="reverse_op mthi move _lo"       # mtlo $t0

alias  mul="execute_MD *"
alias  div="execute_MD /"

# Psuedo intructions
alias rem="not implemented MR_operation %"



reset_registers

